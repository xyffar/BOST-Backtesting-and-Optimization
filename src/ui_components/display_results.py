# display_results.py

from datetime import datetime

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import streamlit as st
import streamlit_bokeh

from src.config.config import MESSAGES, ss
from src.data_handlers.excel_exporter import export_to_excel


def _manage_excel_file_backtest(excel_export_data: dict) -> None:
    """Manage the export and download of backtest results as an Excel file.

    Args:
        excel_export_data (dict): Dictionary containing data to export to Excel.

    Returns:
        None

    """
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["export_results_subheader"])
    # Generate a timestamped filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    excel_filename = f"backtest_results_{timestamp}.xlsx"
    excel_file = export_to_excel(excel_export_data, filename=excel_filename)
    st.download_button(
        label=MESSAGES["display_texts"]["messages"]["download_excel_button"],
        data=excel_file,
        file_name=excel_filename,
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )


def display_results() -> None:
    """Display backtest or optimization results in the Streamlit UI.

    Act as the main rendering entry point after a backtest or optimization run
    is completed. Check the application's mode ('backtest' or 'optimization')
    and whether results have been generated before proceeding.

    Create a tabbed interface, with a separate tab for each ticker that has
    results. Within each tab, delegate the rendering of detailed results to
    mode-specific helper functions: `_display_backtest_results` for backtesting
    and `_display_optimization_results` for optimization.

    For backtest mode, also render a download button to export a comprehensive
    Excel report of the results.

    All necessary data is retrieved from the Streamlit session state (`ss`).
    This function takes no arguments and has no return value.

    Side Effects:
        Renders content to the Streamlit UI, including tabs, dataframes, and plots.

    """
    if (ss.mode == "backtest" and not ss.backtest_results_generated) or (
        ss.mode == "optimization" and not ss.opt_results_generated
    ):
        # st.warning(MESSAGES["display_texts"]["messages"]["no_results_to_show"])
        return

    tickers_with_results = tuple((*ss.bt_stats.keys(), *ss.opt_combs_ranking.keys()))

    tabs = st.tabs(tickers_with_results)

    for i, ticker in enumerate(tickers_with_results):
        with tabs[i]:
            st.markdown(f"""### {MESSAGES["display_texts"]["messages"]["results_for_ticker"].format(ticker=ticker)}""")

            if ss.mode == "optimization":
                _display_optimization_results(
                    ticker
                    # ticker_results[ticker],
                    # benchmark_comparison,
                    # obj_func,
                )
            elif ss.mode == "backtest":
                _display_backtest_results(ticker)
            else:
                st.error("The mode is neither backtesting or optimization!")
    if ss.backtest_results_generated:
        _manage_excel_file_backtest(
            {
                key: (ss.backtest_trade_list.get(key), ss.backtest_comp_with_benchmark_df.get(key))
                for key in ss.backtest_trade_list.keys() | ss.backtest_comp_with_benchmark_df.keys()
            }
        )


def _display_optimization_results(
    ticker: str,
) -> None:
    # (all_comb_data, heatmap_plots, sambo_plots, mc_data) = ticker_result

    # if all_comb_data is None:
    #     return

    show_results_all_combs_with_benchmark(ticker)

    if ticker in ss.opt_heatmaps:
        show_heatmaps(ss.opt_heatmaps[ticker])
    elif ticker in ss.opt_sambo_plots:
        show_sambo_plots(ss.opt_sambo_plots[ticker])
    else:
        st.info(MESSAGES["display_texts"]["messages"]["heatmap_not_available"])

    if ticker in ss.opt_mc_results:
        show_mc_results(ss.opt_mc_results[ticker])


def show_sambo_plots(sambo_plots: list[plt.Figure]) -> None:
    """Display plots generated by the SAMBO optimization method.

    Render a series of plots specific to the SAMBO (Sample-based
    Optimization) method in a horizontal layout. Each plot is displayed
    in its own column.

    Args:
        sambo_plots (list[plt.Figure]): A list of matplotlib Figure objects
            generated by the SAMBO library's plotting functions (e.g.,
            `plot_objective`, `plot_evaluations`, `plot_convergence`).

    """
    if not sambo_plots:
        return

    st.markdown(f"#### {MESSAGES['display_texts']['messages']['sambo_plots']}")
    cols = st.columns(len(sambo_plots))
    for col, fig in zip(cols, sambo_plots, strict=False):
        with col:
            st.pyplot(fig, use_container_width=True)
            plt.close(fig)  # Explicitly close the figure to free up memory


def show_results_all_combs_with_benchmark(ticker: str) -> None:
    """Display the ranked table of all optimization combinations.

    Render a subheader and a Streamlit DataFrame containing the results of all
    parameter combinations from the optimization run for a specific ticker.

    The data, retrieved from `ss.opt_combs_ranking[ticker]`, is expected to be
    pre-sorted and include columns for benchmark comparison. If no data is
    found for the ticker, an informational message is displayed.

    Args:
        ticker (str): The ticker symbol for which to display the results.

    """
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['table_combinations_header']}")

    if ticker not in ss.opt_combs_ranking or ss.opt_combs_ranking[ticker].empty:
        st.info(f"No optimization ranking data available for {ticker}.")
        return

    st.dataframe(ss.opt_combs_ranking[ticker], use_container_width=True)


def show_mc_results(mc_data: pd.DataFrame | None) -> None:
    """Display Monte Carlo analysis results if available.

    Args:
        mc_data (pd.DataFrame | None): Monte Carlo results data to display.

    Returns:
        None

    """
    if mc_data is not None:
        st.markdown("---")
        st.subheader("Analisi Monte Carlo")
        st.dataframe(mc_data)


def show_heatmaps(heatmap_plots: list) -> None:
    """Display optimization heatmap plots in a grid layout.

    Args:
        heatmap_plots (list): List of matplotlib Figure objects to display.

    Returns:
        None

    """
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['optimization_heatmap']}")
    num_columns = 3
    cols = st.columns(num_columns)
    for i, fig in enumerate(heatmap_plots):
        with cols[i % num_columns]:
            st.pyplot(fig, use_container_width=True)
            plt.close(fig)


def _display_backtest_results(ticker: str) -> None:
    if ss.backtest_comp_with_benchmark_df[ticker] is not None:
        st.markdown(f"#### {MESSAGES['display_texts']['messages']['backtest_stats_benchmark_comparison']}")
        st.dataframe(ss.backtest_comp_with_benchmark_df[ticker], use_container_width=True)
    else:
        st.warning(MESSAGES["display_texts"]["messages"]["benchmark_comparison_not_available"])

    st.markdown(f"#### {MESSAGES['display_texts']['messages']['interactive_backtest_chart']}")
    streamlit_bokeh.streamlit_bokeh(
        ss.backtest_interactive_plot[ticker], use_container_width=False, theme="light_minimal"
    )

    st.markdown(f"#### {MESSAGES['display_texts']['messages']['list_of_trades']}")
    if ss.backtest_trade_list[ticker] is not None and not ss.backtest_trade_list[ticker].empty:
        st.dataframe(ss.backtest_trade_list[ticker], use_container_width=True)
    else:
        st.info(MESSAGES["display_texts"]["messages"]["no_trades_executed"])

    if ticker in ss.backtest_mc_percentiles.keys() and ss.backtest_mc_percentiles[ticker] is not None:
        show_montecarlo_results(ticker)


def show_montecarlo_results(ticker: str) -> None:
    """Display detailed Monte Carlo simulation results for a specific ticker.

    Render pre-calculated Monte Carlo analysis results stored in the Streamlit
    session state (`ss`). This includes dataframes for percentile statistics
    and benchmark comparisons, and plots for simulated equity lines and
    metric distributions (e.g., VaR, returns).

    This function assumes that the Monte Carlo analysis has already been run
    and the results are populated in the session state for the given ticker.

    Args:
        ticker (str): The ticker symbol for which to display Monte Carlo results.

    Side Effects:
        - Renders a subheader, dataframes, and plots to the Streamlit UI.
        - Closes matplotlib figures after rendering to free up memory.

    """
    # 1. Retrieve all necessary data from session state using .get() for safety
    percentiles_df = ss.backtest_mc_percentiles.get(ticker)
    benchmark_prob_df = ss.backtest_mc_probs_benchmark.get(ticker)
    equity_lines_plot = ss.backtest_mc_equity_lines_plot.get(ticker)
    var_plot = ss.backtest_mc_var_plot.get(ticker)
    returns_plot = ss.backtest_mc_returns_plot.get(ticker)

    # 2. Validate that all required data is available before attempting to render
    if any(data is None for data in [percentiles_df, benchmark_prob_df, equity_lines_plot, var_plot, returns_plot]):
        st.info(f"Monte Carlo results are not fully available for {ticker}.")
        return

    # 3. Render the UI components
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["monte_carlo_analysis_header"])

    # Display dataframes with styling and optimal width
    st.dataframe(
        percentiles_df.style.format({col: "{:.2f}" for col in percentiles_df.columns}),
        use_container_width=True,
    )
    st.dataframe(benchmark_prob_df, use_container_width=True)

    # Display plots in columns and ensure figures are closed to free memory
    cols = st.columns(3)
    plots_to_show = [equity_lines_plot, var_plot, returns_plot]
    for col, plot_fig in zip(cols, plots_to_show, strict=False):
        with col:
            st.pyplot(plot_fig, use_container_width=True)
            plt.close(plot_fig)


def show_montecarlo_histogram(
    ticker: str,
    metric: np.ndarray | pd.Series,
    title: str,
    x_label: str,
    perc_label: str,
    percentile: int | float,
    nickname: str,
) -> None:
    """Generate a histogram from Monte Carlo simulation metrics and store it.

    Creates a matplotlib histogram for a given performance metric (e.g.,
    Max Drawdown, Return). The plot includes a vertical dashed line to mark a
    specific percentile value, which is useful for visualizing concepts like
    Value at Risk (VaR).

    The generated figure object is not displayed directly but is stored in the
    Streamlit session state (`ss`) for later rendering.

    Args:
        ticker (str): The ticker symbol, used as a key for storing the plot.
        metric (np.ndarray | pd.Series): The data series of a specific metric
            from all Monte Carlo simulations.
        title (str): The title for the histogram plot.
        x_label (str): The label for the x-axis.
        perc_label (str): The descriptive label for the percentile line in the
            legend (e.g., "VaR Drawdown [%]").
        percentile (int | float): The percentile to calculate and mark on the
            histogram (e.g., 5 for the 5th percentile).
        nickname (str): The key under which the generated plot figure will be
            stored in the session state (e.g., `ss[nickname][ticker]`).

    Side Effects:
        - Creates a matplotlib Figure and stores it in `ss[nickname][ticker]`.
        - Displays a warning in the UI if the metric data is empty.

    """
    if metric is None or len(metric) == 0:
        st.warning(f"Cannot generate histogram for '{title}' for ticker {ticker} as no metric data is available.")
        return

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.hist(metric, bins=50, edgecolor="black", alpha=0.7)
    ax.set_title(title)
    ax.set_xlabel(x_label)
    ax.set_ylabel("Frequency")

    percentile_value = np.percentile(metric, percentile)
    confidence_level = 100 - percentile

    # The label indicates the confidence level (e.g., 95%) corresponding to a percentile (e.g., 5th).
    label_text = f"{perc_label} al {confidence_level}%: {percentile_value:.2f}"

    ax.axvline(
        percentile_value,  # Correctly use the calculated percentile value
        color="red",
        linestyle="dashed",
        linewidth=2,
        label=label_text,
    )
    ax.legend()
    ax.grid(True)
    plt.tight_layout()

    # Ensure the nested dictionary for the nickname exists before assignment
    if nickname not in ss:
        ss[nickname] = {}
    ss[nickname][ticker] = fig


def show_montecarlo_equity_lines(
    ticker: str,
    mc_pars: dict,
    simulated_equity_lines: np.ndarray,
    original_equity_path: np.ndarray | pd.Series,
    max_n_shown_lines: int = 200,
) -> None:
    """Generate and store a plot of simulated Monte Carlo equity lines.

    Creates a matplotlib plot showing multiple simulated equity paths from a
    Monte Carlo analysis, highlighting the original path and the paths with
    the maximum and minimum final capital.

    The generated figure is not displayed directly but is stored in the
    Streamlit session state (`ss.backtest_mc_equity_lines_plot[ticker]`) for
    later rendering.

    Args:
        ticker (str): The ticker symbol, used as a key for storing the plot.
        mc_pars (dict): Dictionary of Monte Carlo parameters, must include
                        '# Simulations'.
        simulated_equity_lines (np.ndarray): A 2D NumPy array where each row
                                             is a simulated equity path.
        original_equity_path (np.ndarray | pd.Series): The historical equity curve.
        max_n_shown_lines (int, optional): The maximum number of simulated
                                           equity lines to display to avoid
                                           overcrowding. Defaults to 200.

    Side Effects:
        - Creates a matplotlib Figure and stores it in `ss.backtest_mc_equity_lines_plot[ticker]`.
        - Displays a warning in the UI if input data is invalid.

    """
    # 1. Validate inputs
    if (
        simulated_equity_lines is None
        or simulated_equity_lines.size == 0
        or original_equity_path is None
        or len(original_equity_path) == 0
    ):
        st.warning(f"Cannot generate equity lines plot for {ticker}: simulation data is missing or empty.")
        return

    num_sims = mc_pars.get("# Simulations", 0)
    if num_sims == 0:
        st.warning(f"Cannot generate equity lines plot for {ticker}: number of simulations is zero.")
        return

    # 2. Setup plot
    fig, ax = plt.subplots(figsize=(12, 6))

    # 3. Plot a subset of simulated lines for background context (vectorized for performance)
    num_lines_to_show = min(max_n_shown_lines, num_sims)
    ax.plot(simulated_equity_lines[:num_lines_to_show, :].T, color="lightblue", lw=0.7, alpha=0.6)

    # 4. Find and plot highlighted lines (original, best, and worst cases)
    final_capitals = simulated_equity_lines[:, -1]
    idx_max_equity = np.argmax(final_capitals)
    idx_min_equity = np.argmin(final_capitals)

    ax.plot(original_equity_path, color="black", linewidth=3, label="Original")
    ax.plot(simulated_equity_lines[idx_max_equity, :], color="green", linewidth=2.5, label="Max Final Capital")
    ax.plot(simulated_equity_lines[idx_min_equity, :], color="red", linewidth=2.5, label="Min Final Capital")

    # 5. Style the plot
    ax.set_title(f"Simulation of Monte Carlo Equity Lines ({num_sims} paths)")
    ax.set_xlabel("Trade")
    ax.set_ylabel("Capital")
    ax.grid(True)
    ax.legend()
    plt.tight_layout()

    # 6. Store the plot in session state
    ss.backtest_mc_equity_lines_plot[ticker] = fig
