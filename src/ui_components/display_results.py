# display_results.py

from datetime import datetime
from typing import cast

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import streamlit as st
import streamlit_bokeh
from matplotlib.figure import Figure

from src.config.config import MESSAGES, ss
from src.data_handlers.excel_exporter import export_to_excel
from src.ui_components.interactive_table import DoubleClickTable


def display_results(mode: str = "backtest") -> None:
    """Display backtest or optimization results in the Streamlit UI.

    Act as the main rendering entry point after a backtest or optimization run
    is completed. Check the application's mode ('backtest' or 'optimization')
    and whether results have been generated before proceeding.

    Create a tabbed interface, with a separate tab for each ticker that has
    results. Within each tab, delegate the rendering of detailed results to
    mode-specific helper functions: `_display_backtest_results` for backtesting
    and `_display_optimization_results` for optimization.

    For backtest mode, also render a download button to export a comprehensive
    Excel report of the results.

    All necessary data is retrieved from the Streamlit session state (`ss`).
    This function takes no arguments and has no return value.

    Side Effects:
        Renders content to the Streamlit UI, including tabs, dataframes, and plots.

    """
    if (mode == "backtest" and not ss.backtest_results_generated) or (
        mode == "optimization" and not ss.opt_results_generated
    ):
        # st.warning(MESSAGES["display_texts"]["messages"]["no_results_to_show"])
        return

    tickers_with_results = (
        tuple(ss.bt_stats.keys())
        if mode == "backtest"
        else (tuple(ss.opt_master_results_table.keys()) if mode == "optimization" else "")
    )
    tabs = st.tabs(tickers_with_results)

    for i, ticker in enumerate(tickers_with_results):
        with tabs[i]:
            st.markdown(f"""### {MESSAGES["display_texts"]["messages"]["results_for_ticker"].format(ticker=ticker)}""")

            if mode == "optimization":
                _display_optimization_results(
                    ticker
                    # ticker_results[ticker],
                    # benchmark_comparison,
                    # obj_func,
                )
            elif mode == "backtest":
                _display_backtest_results(ticker)
            else:
                st.error("The mode is neither backtesting or optimization!")

    if ss.backtest_results_generated and mode == "backtest":
        _manage_excel_file_backtest(
            {
                key: (ss.backtest_trade_list.get(key), ss.backtest_comp_with_benchmark_df.get(key))
                for key in ss.backtest_trade_list.keys() | ss.backtest_comp_with_benchmark_df.keys()
            }
        )


def _manage_excel_file_backtest(excel_export_data: dict) -> None:
    """Manage the export and download of backtest results as an Excel file.

    Args:
        excel_export_data (dict): Dictionary containing data to export to Excel.

    Returns:
        None

    """
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["export_results_subheader"])
    # Generate a timestamped filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    excel_filename = f"{MESSAGES['general_settings']['folder_output_files']}/backtest_results_{timestamp}.xlsx"
    excel_file = export_to_excel(excel_export_data, filename=excel_filename)
    st.download_button(
        label=MESSAGES["display_texts"]["messages"]["download_excel_button"],
        data=excel_file,
        file_name=excel_filename,
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )


def _display_optimization_results(
    ticker: str,
) -> None:
    _show_results_all_combs_with_benchmark(ticker)

    if ticker in ss.opt_heatmaps:
        show_heatmaps(ss.opt_heatmaps[ticker])
    elif ticker in ss.opt_sambo_plots:
        show_sambo_plots(ss.opt_sambo_plots[ticker])
    else:
        st.info(MESSAGES["display_texts"]["messages"]["heatmap_not_available"])

    if ticker in ss.opt_mc_results:
        show_mc_results(ss.opt_mc_results[ticker])


def show_sambo_plots(sambo_plots: list[Figure]) -> None:
    """Display plots generated by the SAMBO optimization method.

    Render a series of plots specific to the SAMBO (Sample-based
    Optimization) method in a horizontal layout. Each plot is displayed
    in its own column.

    Args:
        sambo_plots (list[plt.Figure]): A list of matplotlib Figure objects
            generated by the SAMBO library's plotting functions (e.g.,
            `plot_objective`, `plot_evaluations`, `plot_convergence`).

    """
    if not sambo_plots:
        return

    st.markdown(f"#### {MESSAGES['display_texts']['messages']['sambo_plots']}")
    cols = st.columns(len(sambo_plots))
    for col, fig in zip(cols, sambo_plots, strict=False):
        with col:
            st.pyplot(fig, use_container_width=True)
            plt.close(fig)  # Explicitly close the figure to free up memory


def _show_results_all_combs_with_benchmark(ticker: str) -> None:
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['table_combinations_header']}")

    # 1. Retrieve the results table for the specified ticker
    results = ss.opt_master_results_table.get(ticker).copy()
    # 2. Check if results are available
    if results is None or results.empty:
        st.info(f"No optimization ranking data available for {ticker}.")
        return

    # 3. Manipulate the result dataframe to show the most important statistics
    results = _select_relevant_statistics(results)

    # 4. Display the table with the selected statistics
    _display_opt_results_table(ticker=ticker, results=results, all_data=ss.opt_master_results_table.get(ticker))


def _select_relevant_statistics(results: pd.DataFrame) -> pd.DataFrame:
    # 3. Get the statistics to show in the main table
    stats_to_show = [stat["name"] for stat in MESSAGES["all_stats_properties"] if stat.get("opt_main_stat")]

    # 4. Select only the wanted columns
    available_columns = results.columns
    cols_to_show = [
        col
        for col in available_columns
        if col in list(zip(["BT Stats"] * len(stats_to_show), stats_to_show, strict=False))
        or col[0] == "Strategy"
        or col == ("Bench. Comp. [%]", results.attrs["objective_func"])
        or col
        == (
            "Monte Carlo",
            f"{results.attrs['objective_func']} (p{sorted(MESSAGES['monte_carlo_percentiles'], reverse=True)[1]})",
        )
        or col == ("Monte Carlo", f"{results.attrs['objective_func']} (P[%]>Bench)")
    ]
    results = results[cols_to_show]

    # 5. Improve readability of the param values by separating them with commas
    #    and rounding to 2 decimal places
    results[("Strategy", "Param Values")] = results[("Strategy", "Param Values")].map(
        lambda x: ", ".join(tuple(str(round(el, 2)) for el in x)) if isinstance(x, (list, tuple)) else x
    )

    # 6. If the opt is single strategy, exlude strat name and param names columns. Put the param names as a header
    if results[("Strategy", "Strat Name")].nunique() == 1:
        par_names = ", ".join(results[("Strategy", "Param Names")].iloc[0])
        results[("Strategy", par_names)] = results[("Strategy", "Param Values")]
        results = results.drop(
            columns=[("Strategy", "Strat Name"), ("Strategy", "Param Names"), ("Strategy", "Param Values")]
        )

    # 7. Sort column order to have Strategy columns first, then the rest
    results = results.reindex(
        columns=[col for col in results.columns if col[0] == "Strategy"]
        + [col for col in results.columns if col[0] != "Strategy"]
    )

    return results


@st.fragment
def _display_opt_results_table(ticker: str, results: pd.DataFrame, all_data: pd.DataFrame) -> None:
    results.columns = _rename_stat_columns(results)

    result_table = DoubleClickTable(
        df=results, key=f"opt_results_{ticker}", max_height=500, double_clickable=True, mixed_columns=False
    )

    result_table.display()

    if result_table.is_double_clicked:
        _popup_show_details(ticker, result_table, all_data=all_data)


def _rename_stat_columns(df: pd.DataFrame) -> pd.Index:
    """Rename columns in a DataFrame using statistics from YAML.

    Args:
        df (pd.DataFrame): DataFrame to rename columns in.

    Returns:
        pd.Index: Renamed column index.

    """
    # Map statistics from YAML so we can use their nicknames for readability
    all_stats_map: dict[str, dict[str, str | bool]] = {stat["name"]: stat for stat in MESSAGES["all_stats_properties"]}

    if isinstance(df.columns, pd.MultiIndex):
        # Use a list comprehension to get pairs (name, nickname)
        return df.columns.set_levels(
            [all_stats_map.get(col, {}).get("nickname", col) for col in df.columns.levels[-1]], level=-1
        )

    else:
        return pd.Index([all_stats_map.get(col, {}).get("nickname", col) for col in df.columns])


def show_mc_results(mc_data: pd.DataFrame | None) -> None:
    """Display Monte Carlo analysis results if available.

    Args:
        mc_data (pd.DataFrame | None): Monte Carlo results data to display.

    Returns:
        None

    """
    if mc_data is not None:
        st.markdown("---")
        st.subheader("Analisi Monte Carlo")
        st.dataframe(mc_data)


def show_heatmaps(heatmap_plots: list) -> None:
    """Display optimization heatmap plots in a grid layout.

    Args:
        heatmap_plots (list): List of matplotlib Figure objects to display.

    Returns:
        None

    """
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['optimization_heatmap']}")
    num_columns = 3
    cols = st.columns(num_columns)
    for i, fig in enumerate(heatmap_plots):
        with cols[i % num_columns]:
            st.pyplot(fig, use_container_width=True)
            plt.close(fig)


@st.fragment
def _display_backtest_results(ticker: str) -> None:
    """Display detailed backtest results for a specific ticker.

    Render pre-calculated backtest analysis results stored in the Streamlit
    session state (`ss`). This includes dataframes for benchmark comparisons
    and trade lists, and plots for backtest equity lines and Monte Carlo
    analysis (if available).

    This function assumes that the backtest analysis has already been run
    and the results are populated in the session state for the given ticker.

    Args:
        ticker (str): The ticker symbol for which to display backtest results.

    Side Effects:
        - Renders a subheader, dataframes, and plots to the Streamlit UI.
        - Closes matplotlib figures after rendering to free up memory.

    """
    _show_backtest_benchmark_results(ticker)

    _render_backtest_chart(ticker)

    _display_trade_list(ticker)

    _show_montecarlo_results(ticker)


@st.fragment
def _render_backtest_chart(ticker: str) -> None:
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['interactive_backtest_chart']}")
    streamlit_bokeh.streamlit_bokeh(
        ss.backtest_interactive_plot[ticker], use_container_width=False, theme="light_minimal"
    )


@st.fragment
def _display_trade_list(ticker: str) -> None:
    st.markdown(f"#### {MESSAGES['display_texts']['messages']['list_of_trades']}")
    if ss.backtest_trade_list[ticker] is not None and not ss.backtest_trade_list[ticker].empty:
        # st.dataframe(ss.backtest_trade_list[ticker], use_container_width=True)
        trade_df = DoubleClickTable(
            df=ss.backtest_trade_list[ticker].reset_index(drop=False),
            key=f"trade_list_{ticker}",
            max_height=500,
            double_clickable=False,
            mixed_columns=False,
        )
        trade_df.display()

    else:
        st.info(MESSAGES["display_texts"]["messages"]["no_trades_executed"])


@st.fragment
def _show_backtest_benchmark_results(ticker: str) -> None:
    if ss.backtest_comp_with_benchmark_df[ticker] is not None:
        st.markdown(f"#### {MESSAGES['display_texts']['messages']['backtest_stats_benchmark_comparison']}")
        # st.dataframe(ss.backtest_comp_with_benchmark_df[ticker], use_container_width=True)
        result_table = DoubleClickTable(
            df=ss.backtest_comp_with_benchmark_df[ticker].reset_index(drop=False),
            key=f"backtest_comparison_{ticker}",
            max_height=500,
            double_clickable=True,
            mixed_columns=True,
        )
        result_table.display()

    else:
        st.warning(MESSAGES["display_texts"]["messages"]["benchmark_comparison_not_available"])


# @st.dialog("Optimization - More Details", width="large")
def _popup_show_details(ticker: str, result_table: DoubleClickTable, all_data: pd.DataFrame) -> None:
    idx = result_table.idx_last_double_clicked
    try:
        row = cast(pd.Series, all_data.loc[idx])  # Try to access by label first
    except KeyError:
        try:
            idx = int(idx) if idx is not None else -1  # Try to convert to int for positional access
        except ValueError:  # If conversion fails, it's not a valid index
            st.error(f"Invalid index: {idx}")
            return
        row = cast(pd.Series, all_data.loc[idx])

    st.markdown(f"#### {MESSAGES['display_texts']['messages']['details_for_ticker'].format(ticker=ticker)}")

    # 1. Show strategy parameters
    _display_strategy_parameters(row)

    cols = st.columns([0.5, 0.5], gap="small", vertical_alignment="top")
    # 2. Show all stats compared to the benchmark
    with cols[0]:
        _display_comparison_stats(ticker, row)

    # 3. Show Monte Carlo stats
    with cols[1]:
        _display_monte_carlo_statistics(ticker, row)


def _display_strategy_parameters(row: pd.Series) -> None:
    params = list(zip(row.loc["Strategy", "Param Names"], row.loc["Strategy", "Param Values"], strict=False))
    params_df = pd.Series({p[0]: p[1] for p in params}, name="Param Values").to_frame().T.reset_index(drop=True)
    st.dataframe(params_df, use_container_width=True, hide_index=True)


def _display_comparison_stats(ticker: str, row: pd.Series) -> None:
    stats = row.copy()
    needed_data = ["BT Stats", "Benchmark Stats", "Bench. Comp. [%]"]
    stat_table = (
        pd.DataFrame({data: stats.loc[data] for data in needed_data})
        .drop(["Trade_returns", "Equity_curve"], axis=0, inplace=False)
        .reset_index(drop=False)
    )

    table = DoubleClickTable(
        df=stat_table,
        max_height=800,
        mixed_columns=False,
        double_clickable=False,
        key=f"opt_comparison_popup_{ticker}",
    )
    table.display()


def _display_monte_carlo_statistics(ticker: str, row: pd.Series) -> None:
    try:
        mc_data = row.copy()
        mc_data = mc_data["Monte Carlo"]
    except KeyError:
        return

    stat__perc = mc_data.index.str.extract(r"(.*?)\s*\((.*?)\)$")
    stat__perc.columns = ["Stat", "Pct"]
    mc_table = pd.concat([stat__perc, mc_data.reset_index(drop=True)], axis=1)

    mc_table = mc_table.pivot_table(
        index="Pct",
        columns="Stat",
    )
    mc_table.columns = [f"{col[1]}" for col in mc_table.columns]
    mc_table = mc_table.apply(pd.to_numeric, errors="ignore")

    mc_table.columns = _rename_stat_columns(mc_table)

    table1 = DoubleClickTable(
        df=mc_table.reset_index(drop=False),
        max_height=800,
        mixed_columns=False,
        double_clickable=False,
        key=f"opt_monte_carlo_popup_{ticker}",
    )
    table1.display()


def _show_montecarlo_results(ticker: str) -> None:
    """Display detailed Monte Carlo simulation results for a specific ticker.

    Render pre-calculated Monte Carlo analysis results stored in the Streamlit
    session state (`ss`). This includes dataframes for percentile statistics
    and benchmark comparisons, and plots for simulated equity lines and
    metric distributions (e.g., VaR, returns).

    This function assumes that the Monte Carlo analysis has already been run
    and the results are populated in the session state for the given ticker.

    Args:
        ticker (str): The ticker symbol for which to display Monte Carlo results.

    Side Effects:
        - Renders a subheader, dataframes, and plots to the Streamlit UI.
        - Closes matplotlib figures after rendering to free up memory.

    """
    if ticker not in ss.backtest_mc_percentiles.keys() or ss.backtest_mc_percentiles[ticker] is None:
        return

    # 1. Retrieve all necessary data from session state using .get() for safety
    percentiles_df = ss.backtest_mc_percentiles.get(ticker)
    benchmark_prob_df = ss.backtest_mc_probs_benchmark.get(ticker)
    equity_lines_plot = ss.backtest_mc_equity_lines_plot.get(ticker)
    var_plot = ss.backtest_mc_var_plot.get(ticker)
    returns_plot = ss.backtest_mc_returns_plot.get(ticker)

    # 2. Validate that all required data is available before attempting to render
    if any(data is None for data in [percentiles_df, benchmark_prob_df, equity_lines_plot, var_plot, returns_plot]):
        st.info(f"Monte Carlo results are not fully available for {ticker}.")
        return

    # 3. Render the UI components
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["monte_carlo_analysis_header"])

    # Display dataframes with styling and optimal width
    st.dataframe(
        percentiles_df.style.format({col: "{:.2f}" for col in percentiles_df.columns}),
        use_container_width=True,
    )
    st.dataframe(benchmark_prob_df, use_container_width=True)

    # Display plots in columns and ensure figures are closed to free memory
    cols = st.columns(3)
    plots_to_show = [equity_lines_plot, var_plot, returns_plot]
    for col, plot_fig in zip(cols, plots_to_show, strict=False):
        with col:
            st.pyplot(plot_fig, use_container_width=True)
            plt.close(plot_fig)


@st.fragment
def show_montecarlo_histogram(
    ticker: str,
    metric: np.ndarray | pd.Series,
    title: str,
    x_label: str,
    perc_label: str,
    percentile: int | float,
    nickname: str,
) -> None:
    """Generate a histogram from Monte Carlo simulation metrics and store it.

    Creates a matplotlib histogram for a given performance metric (e.g.,
    Max Drawdown, Return). The plot includes a vertical dashed line to mark a
    specific percentile value, which is useful for visualizing concepts like
    Value at Risk (VaR).

    The generated figure object is not displayed directly but is stored in the
    Streamlit session state (`ss`) for later rendering.

    Args:
        ticker (str): The ticker symbol, used as a key for storing the plot.
        metric (np.ndarray | pd.Series): The data series of a specific metric
            from all Monte Carlo simulations.
        title (str): The title for the histogram plot.
        x_label (str): The label for the x-axis.
        perc_label (str): The descriptive label for the percentile line in the
            legend (e.g., "VaR Drawdown [%]").
        percentile (int | float): The percentile to calculate and mark on the
            histogram (e.g., 5 for the 5th percentile).
        nickname (str): The key under which the generated plot figure will be
            stored in the session state (e.g., `ss[nickname][ticker]`).

    Side Effects:
        - Creates a matplotlib Figure and stores it in `ss[nickname][ticker]`.
        - Displays a warning in the UI if the metric data is empty.

    """
    if metric is None or len(metric) == 0:
        st.warning(f"Cannot generate histogram for '{title}' for ticker {ticker} as no metric data is available.")
        return

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.hist(metric, bins=50, edgecolor="black", alpha=0.7)
    ax.set_title(title)
    ax.set_xlabel(x_label)
    ax.set_ylabel("Frequency")

    percentile_value = np.percentile(metric, percentile)
    confidence_level = 100 - percentile

    # The label indicates the confidence level (e.g., 95%) corresponding to a percentile (e.g., 5th).
    label_text = f"{perc_label} al {confidence_level}%: {percentile_value:.2f}"

    ax.axvline(
        float(percentile_value),  # Explicitly cast to float for compatibility
        color="red",
        linestyle="dashed",
        linewidth=2,
        label=label_text,
    )
    ax.legend()
    ax.grid(True)
    plt.tight_layout()

    # Ensure the nested dictionary for the nickname exists before assignment
    if nickname not in ss:
        ss[nickname] = {}
    ss[nickname][ticker] = fig


def show_montecarlo_equity_lines(
    ticker: str,
    mc_pars: dict,
    simulated_equity_lines: np.ndarray,
    original_equity_path: np.ndarray | pd.Series,
    max_n_shown_lines: int = 200,
) -> None:
    """Generate and store a plot of simulated Monte Carlo equity lines.

    Creates a matplotlib plot showing multiple simulated equity paths from a
    Monte Carlo analysis, highlighting the original path and the paths with
    the maximum and minimum final capital.

    The generated figure is not displayed directly but is stored in the
    Streamlit session state (`ss.backtest_mc_equity_lines_plot[ticker]`) for
    later rendering.

    Args:
        ticker (str): The ticker symbol, used as a key for storing the plot.
        mc_pars (dict): Dictionary of Monte Carlo parameters, must include
                        '# Simulations'.
        simulated_equity_lines (np.ndarray): A 2D NumPy array where each row
                                             is a simulated equity path.
        original_equity_path (np.ndarray | pd.Series): The historical equity curve.
        max_n_shown_lines (int, optional): The maximum number of simulated
                                           equity lines to display to avoid
                                           overcrowding. Defaults to 200.

    Side Effects:
        - Creates a matplotlib Figure and stores it in `ss.backtest_mc_equity_lines_plot[ticker]`.
        - Displays a warning in the UI if input data is invalid.

    """
    # 1. Validate inputs
    if (
        simulated_equity_lines is None
        or simulated_equity_lines.size == 0
        or original_equity_path is None
        or len(original_equity_path) == 0
    ):
        st.warning(f"Cannot generate equity lines plot for {ticker}: simulation data is missing or empty.")
        return

    num_sims = mc_pars.get("# Simulations", 0)
    if num_sims == 0:
        st.warning(f"Cannot generate equity lines plot for {ticker}: number of simulations is zero.")
        return

    # 2. Setup plot
    fig, ax = plt.subplots(figsize=(12, 6))

    # 3. Plot a subset of simulated lines for background context (vectorized for performance)
    num_lines_to_show = min(max_n_shown_lines, num_sims)
    ax.plot(simulated_equity_lines[:num_lines_to_show, :].T, color="lightblue", lw=0.7, alpha=0.6)

    # 4. Find and plot highlighted lines (original, best, and worst cases)
    final_capitals = simulated_equity_lines[:, -1]
    idx_max_equity = np.argmax(final_capitals)
    idx_min_equity = np.argmin(final_capitals)

    ax.plot(original_equity_path, color="black", linewidth=3, label="Original")
    ax.plot(simulated_equity_lines[idx_max_equity, :], color="green", linewidth=2.5, label="Max Final Capital")
    ax.plot(simulated_equity_lines[idx_min_equity, :], color="red", linewidth=2.5, label="Min Final Capital")

    # 5. Style the plot
    ax.set_title(f"Simulation of Monte Carlo Equity Lines ({num_sims} paths)")
    ax.set_xlabel("Trade")
    ax.set_ylabel("Capital")
    ax.grid(True)
    ax.legend()
    plt.tight_layout()

    # 6. Store the plot in session state
    ss.backtest_mc_equity_lines_plot[ticker] = fig
