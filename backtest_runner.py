# backtest_runner.py

import os
import time
from copy import deepcopy
from datetime import datetime

import numpy as np  # Importa numpy per np.nan
import pandas as pd
import streamlit as st
from backtesting import Backtest

from config import MESSAGES, session_state_names, ss, streamlit_obj
from data_handler import download_data, get_sp500_data
from display_results import display_results, show_montecarlo_equity_lines, show_montecarlo_histogram
from excel_exporter import export_to_excel, log_execution_data
from monte_carlo import run_montecarlo
from strategies.buy_and_hold_strategy import BuyAndHoldStrategy
from strategies.common_strategy import CommonStrategy


def compare_with_benchmark(strategy_stats: pd.Series, benchmark_stats: pd.Series | None) -> pd.DataFrame:
    """Create a DataFrame that compares the performance metrics of the strategy with the benchmark.

    Metrics include various return measures, volatility, Sharpe ratio, Sortino ratio,
    drawdowns, trade statistics, and other performance indicators.

    Args:
        strategy_stats (pd.Series): Complete statistics from the strategy backtest
                                    (output of `Backtest.run()`).
        benchmark_stats (pd.Series): Complete statistics from the Buy & Hold benchmark
                                     backtest (output of `Backtest.run()`). Can be None
                                     if benchmark data is not available.

    Returns:
        pd.DataFrame: A DataFrame comparing key metrics of the strategy and the benchmark,
                      with metrics as index and 'Strategia' and 'Benchmark (SPY)' as columns.
                      Numeric values are rounded to two decimal places.

    """
    metrics_to_display = [
        "Exposure Time [%]",
        "Equity Final [$]",  # Aggiunto simbolo valuta per chiarezza
        "Return [%]",
        "Return (Ann.) [%]",
        "Volatility (Ann.) [%]",
        "Sharpe Ratio",
        "Sortino Ratio",
        "Calmar Ratio",
        "Max. Drawdown [%]",
        "Max. Drawdown Duration",
        "Avg. Drawdown Duration",
        "# Trades",
        "Win Rate [%]",
        "Avg. Trade Duration",
        "SQN",
    ]

    strategy_values = []
    benchmark_values = []

    for metric in metrics_to_display:
        strategy_value = strategy_stats.get(metric, np.nan)
        benchmark_value = benchmark_stats.get(metric, np.nan) if benchmark_stats is not None else np.nan

        # Arrotonda i valori numerici a due cifre decimali
        if isinstance(strategy_value, (int, float)) and not np.isnan(strategy_value) and not np.isinf(strategy_value):
            strategy_values.append(round(strategy_value, 2))
        else:
            strategy_values.append(strategy_value)

        if (
            isinstance(benchmark_value, (int, float))
            and not np.isnan(benchmark_value)
            and not np.isinf(benchmark_value)
        ):
            benchmark_values.append(round(benchmark_value, 2))
        else:
            benchmark_values.append(benchmark_value)

    comparison_df = pd.DataFrame(
        {
            "Metrica": metrics_to_display,
            "Strategia": strategy_values,
            "Benchmark (SPY)": benchmark_values,
        }
    )
    comparison_df.set_index("Metrica", inplace=True)
    if comparison_df is not None:
        styled_comparison_df = comparison_df.copy()
    for col in styled_comparison_df.select_dtypes(include=np.number).columns:
        styled_comparison_df[col] = styled_comparison_df[col].round(2)

    return styled_comparison_df


def run_backtest(
    ticker: str,
    data: pd.DataFrame,
    strategy_name: str,
    params: dict,
    initial_capital: float,
    commission_percent: float,
    is_plot_wanted: bool = True,
) -> tuple[pd.Series | None, str | None, pd.DataFrame | None, str, str]:
    """Run a backtest for a given strategy and data using the `backtesting.py` library.

    Logs execution times and can optionally generate an interactive plot of the equity curve.

    Args:
        data (pd.DataFrame): Historical market data (OHLCV) on which to run the backtest.
                             Must be in the format expected by `backtesting.py`.
        strategy_name (str): The name of the strategy to backtest.
        params (dict): A dictionary of parameters to pass to the strategy's `init` method.
        initial_capital (float): The initial capital for the backtest.
        commission_percent (float): Commission percentage per trade (e.g., 0.002 for 0.2%).
        is_plot_wanted (bool, optional): If True, an interactive Bokeh plot of the
                                         equity curve will be generated and returned as HTML.
                                         Defaults to True.

    Returns:
        tuple: A tuple containing:
               - stats (pd.Series or None): Statistics of the backtest generated by `bt.run()`.
                                            Returns None if the backtest fails.
               - plot_html (str or None): HTML string of the interactive Bokeh plot.
                                          Returns None if `is_plot_wanted` is False or if backtest fails.
               - trades_df (pd.DataFrame or None): DataFrame containing details of individual trades.
                                                   Returns None if the backtest fails.
               - status (str): "success" if the backtest ran without errors, "failure" otherwise.
               - message (str): A descriptive message indicating the outcome or error.

    """
    if data is None or data.empty:
        st.error("Impossibile eseguire il backtest: dati non disponibili.")
        return

    strat_class: type[CommonStrategy] = st.session_state.all_strategies[strategy_name]
    bt = Backtest(
        data,
        strat_class,
        cash=initial_capital,
        commission=commission_percent,
        exclusive_orders=True,  # Consente una sola posizione alla volta
    )

    try:
        start_time = time.perf_counter()
        ss.bt_stats[ticker] = bt.run(**params)
        end_time = time.perf_counter()
        pars_time_log = {"periods": len(data), "strategy": strat_class.DISPLAY_NAME}
        log_execution_data(start_time, end_time, action="Backtest", **pars_time_log)

        if is_plot_wanted:
            start_time = time.perf_counter()
            ss.backtest_interactive_plot[ticker] = bt.plot(
                filename="TO BE DELETED.html", resample=False, open_browser=False
            )
            if os.path.exists("TO BE DELETED.html"):
                os.remove("TO BE DELETED.html")
            end_time = time.perf_counter()
            log_execution_data(start_time, end_time, action="Backtest_plot", **pars_time_log)

        ss.backtest_trade_list[ticker] = ss.bt_stats[ticker]._trades

        return

    except Exception as e:
        st.error(
            f"Errore durante l'esecuzione del backtest: {e}. Controlla i parametri della strategia o la logica interna."
        )
        return


def get_benchmark_data(
    download_progress_placeholder: streamlit_obj,
    download_success_placeholder: streamlit_obj,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
) -> pd.Series | None:
    """Download S&P500 data and run a Buy & Hold backtest on it to serve as a benchmark.

    This function handles the data download process and the subsequent backtest
    execution for the benchmark.

    Args:
        start_date_yf (str): Start date for data download in YYYY-MM-DD format,
                             compatible with `yfinance`.
        end_date_yf (str): End date for data download in YYYY-MM-DD format,
                           compatible with `yfinance`.
        data_interval (str): Data interval (e.g., "1d" for daily, "1h" for hourly).
                             Must be compatible with `yfinance` intervals.
        initial_capital (float): Initial capital for the benchmark backtest.
        commission_percent (float): Commission percentage to apply to the benchmark
                                    Buy & Hold backtest.
        download_progress_placeholder (streamlit.delta_generator.DeltaGenerator):
            A Streamlit placeholder object to display download progress messages.
        download_success_placeholder (streamlit.delta_generator.DeltaGenerator):
            A Streamlit placeholder object to display download success messages.
        successful_downloads_tickers (list): A list to append the ticker of
                                             successfully downloaded data.
        failed_downloads_tickers (list): A list to append the ticker of
                                         failed data downloads.

    Returns:
        pd.Series or None: Statistics of the Buy & Hold benchmark backtest
                           (output of `Backtest.run()`). Returns None if data
                           download or backtest execution fails.

    """
    benchmark_raw_data = None  # Raw benchmark data
    benchmark_stats = None  # Complete benchmark buy&hold statistics

    # Download benchmark data
    download_progress_placeholder.info(
        MESSAGES["display_texts"]["messages"]["downloading_benchmark"].format(
            SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"]
        )
    )
    benchmark_raw_data, status, msg = get_sp500_data(ss.start_date_wid, ss.end_date_wid, ss.data_interval_wid)
    download_progress_placeholder.empty()  # Remove blue progress box

    if status == "success":
        successful_downloads_tickers.append(MESSAGES["general_settings"]["sp500_ticker"])
        download_success_placeholder.success(
            MESSAGES["display_texts"]["messages"]["download_success_benchmark"].format(
                SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"]
            )
        )

        # Run a backtest with BuyAndHold strategy on the benchmark
        if benchmark_raw_data is not None and not benchmark_raw_data.empty:
            try:
                bt_benchmark = Backtest(
                    benchmark_raw_data,
                    BuyAndHoldStrategy,  # Use the BuyAndHold strategy
                    cash=ss.initial_capital_wid,
                    commission=ss.commission_percent_wid / 100,  # Apply commissions to benchmark too for parity
                    exclusive_orders=True,
                )
                benchmark_stats = bt_benchmark.run()
            except Exception as e:
                st.warning(
                    MESSAGES["display_texts"]["messages"]["error_calculating_benchmark_stats"].format(
                        SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"], e=e
                    )
                )
                benchmark_stats = None
    else:
        failed_downloads_tickers.append(MESSAGES["general_settings"]["sp500_ticker"])
        st.warning(MESSAGES["display_texts"]["messages"]["benchmark_data_not_available"])
    return benchmark_stats


def start_backtest_process(
    backtest_infos_container: streamlit_obj,
    backtest_results_container: streamlit_obj,
) -> None:
    """Run the backtest process for the given tickers and strategy.

    This function manages the download of data, execution of backtests, Monte Carlo simulation, and result export for all selected tickers.

    Args:
        tickers (list[str]): List of ticker symbols to backtest.
        start_date_yf (str): Start date for data download.
        end_date_yf (str): End date for data download.
        data_interval (str): Data granularity (e.g., '1d').
        initial_capital (float): Initial capital for the backtest.
        commission_percent (float): Commission percentage for trades.
        run_mc (bool): Whether to run Monte Carlo simulation.
        mc_sampling_method (str): Monte Carlo sampling method.
        sims_length (int): Number of trades per simulation.
        num_sims (int): Number of Monte Carlo simulations.
        strat_name (str): The name of the selected strategy.
        strategy_params (dict): Parameters for the selected strategy.
        backtest_results_container (streamlit.delta_generator.DeltaGenerator): Streamlit container for displaying backtest results.

    Returns:
        None

    """
    # for name in session_state_names:
    #     if session_state_names[name][1]:
    #         ss[name] = session_state_names[name][0]

    # Reset the result relatedsession states
    ss.update(
        {name: deepcopy(session_state_names[name][0]) for name in session_state_names if session_state_names[name][1]}
    )
    backtest_infos_container.empty()
    backtest_results_container.empty()

    with backtest_infos_container:
        col_progress, col_success, col_failed = st.columns(3)
        if not ss.tickers:
            st.error(MESSAGES["display_texts"]["messages"]["enter_ticker_error"])
            return
        elif ss.bt_strategy_wid is None:
            st.error(MESSAGES["display_texts"]["messages"]["select_valid_strategy_error"])
            return

    # Placeholders for dynamic messages
    with col_progress:
        download_progress_placeholder = st.empty()
        download_success_placeholder = st.empty()
    with col_success:
        run_progress_placeholder = st.empty()
        run_success_placeholder = st.empty()
    with col_failed:
        download_fail_placeholder = st.empty()
        run_fail_placeholder = st.empty()  # For backtest/optimization success/failure messages

    benchmark_stats = get_benchmark_data(
        download_progress_placeholder,
        download_success_placeholder,
        ss.successful_downloads_tickers,
        ss.failed_downloads_tickers,
    )

    with backtest_infos_container:
        progress_bar = st.progress(0)

    with backtest_results_container:
        for i, ticker in enumerate(ss.tickers):
            _process_single_ticker(
                ticker,
                i,
                benchmark_stats,
                download_progress_placeholder,
                download_success_placeholder,
                download_fail_placeholder,
                run_progress_placeholder,
                run_success_placeholder,
                run_fail_placeholder,
                ss.successful_downloads_tickers,
                ss.failed_downloads_tickers,
                ss.successful_runs_tickers,
                ss.failed_runs_tickers,
                progress_bar,
            )
    ss.backtest_results_generated = True


def _process_single_ticker(
    ticker: str,
    i: int,
    benchmark_stats: pd.Series | None,
    download_progress_placeholder: streamlit_obj,
    download_success_placeholder: streamlit_obj,
    download_fail_placeholder: streamlit_obj,
    run_progress_placeholder: streamlit_obj,
    run_success_placeholder: streamlit_obj,
    run_fail_placeholder: streamlit_obj,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
    successful_runs_tickers: list,
    failed_runs_tickers: list,
    progress_bar: streamlit_obj,
) -> None:
    download_progress_placeholder.info(
        MESSAGES["display_texts"]["messages"]["downloading_ticker"].format(
            ticker=ticker, current_idx=i + 1, total_tickers=len(ss.tickers)
        )
    )

    data, status, _ = download_data(ticker, ss.start_date_wid, ss.end_date_wid, ss.data_interval_wid)

    download_progress_placeholder.empty()  # Remove blue progress box

    _update_download_status(
        status,
        ticker,
        successful_downloads_tickers,
        failed_downloads_tickers,
        download_success_placeholder,
        download_fail_placeholder,
    )

    if data is not None:
        run_progress_placeholder.info(MESSAGES["display_texts"]["messages"]["execution_in_progress"] + ticker)
        try:
            run_backtest(
                ticker,
                data,
                ss.bt_strategy_wid,
                ss.bt_params,
                ss.initial_capital_wid,
                ss.commission_percent_wid / 100,
                True,
            )
            run_status = "success"
        except Exception:
            run_status = "fail"
        run_progress_placeholder.empty()
    else:
        run_status = "fail"

    _update_run_status(
        run_status,
        ticker,
        successful_runs_tickers,
        failed_runs_tickers,
        run_success_placeholder,
        run_fail_placeholder,
    )

    if ticker not in ss.bt_stats.keys() or ss.bt_stats[ticker] is None:
        return

    if benchmark_stats is not None:
        ss.backtest_comp_with_benchmark_df[ticker] = compare_with_benchmark(ss.bt_stats[ticker], benchmark_stats)

    progress_bar.progress((i + 1) / len(ss.tickers))

    if (
        ss.run_mc_wid
        and data is not None
        and run_status == "success"
        and ss.backtest_trade_list[ticker] is not None
        and ss.bt_stats[ticker] is not None
    ):
        run_montecarlo(
            ticker=ticker,
            trades=list(ss.backtest_trade_list[ticker]["ReturnPct"]),
            original_stats=ss.bt_stats[ticker],
            initial_capital=ss.initial_capital_wid,
            benchmark=benchmark_stats,
            sampling_method=ss.mc_sampling_method_wid,
            sim_length=ss.mc_sim_length_wid,
            num_sims=ss.mc_n_sims_wid,
        )
        if ss.backtest_mc_percentiles[ticker] is not None and ss.backtest_mc_probs_benchmark[ticker] is not None:
            # Grafico 1: Equity Lines Simulate
            show_montecarlo_equity_lines(
                ticker,
                ss.mc_pars,
                ss.matrice_equity_lines_simulati,
                ss.orig_current_equity_path,
                max_n_shown_lines=1000,
            )

            # Grafico 2: Istogramma della Distribuzione dei Drawdown Massimi
            show_montecarlo_histogram(
                ticker=ticker,
                metric=ss.mc_metrics_data["Max. Drawdown [%]"],
                title="Distribution of Simulated Max Drawdowns",
                x_label="Max. Drawdown [%]",
                perc_label="VaR Drawdown [%]",
                percentile=5,
                nickname="backtest_mc_var_plot",
            )

            # Grafico 3: Istogramma della Distribuzione del Capitale Finale
            show_montecarlo_histogram(
                ticker=ticker,
                metric=ss.mc_metrics_data["Return [%]"],
                title="Distribution of Return [%]",
                x_label="Return [%]",
                perc_label="Return [%]",
                percentile=5,
                nickname="backtest_mc_returns_plot",
            )

        else:
            st.warning(
                "The Monte Carlo statistics aren't available as the simulation returned "
                "None instead of dataframes. Check the outcome of the simulation"
            )


def _update_download_status(
    status: str,
    ticker: str,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
    download_success_placeholder: streamlit_obj,
    download_fail_placeholder: streamlit_obj,
) -> None:
    if status == "success":
        successful_downloads_tickers.append(ticker)
        download_success_placeholder.success(
            MESSAGES["display_texts"]["messages"]["download_success_ticker"] + ", ".join(successful_downloads_tickers)
        )
    else:
        failed_downloads_tickers.append(ticker)
        download_fail_placeholder.error(
            MESSAGES["display_texts"]["messages"]["download_failed_ticker"] + ", ".join(failed_downloads_tickers)
        )


def _update_run_status(
    run_status: str,
    ticker: str,
    successful_runs_tickers: list,
    failed_runs_tickers: list,
    run_success_placeholder: streamlit_obj,
    run_fail_placeholder: streamlit_obj,
) -> None:
    if run_status != "success":
        failed_runs_tickers.append(ticker)
        run_fail_placeholder.error(
            MESSAGES["display_texts"]["messages"]["execution_failed"] + ", ".join(failed_runs_tickers)
        )
        return

    successful_runs_tickers.append(ticker)
    run_success_placeholder.success(
        MESSAGES["display_texts"]["messages"]["execution_completed"] + ", ".join(successful_runs_tickers)
    )


def _manage_excel_file_backtest(excel_export_data: dict) -> None:
    """Manage the export and download of backtest results as an Excel file.

    Args:
        excel_export_data (dict): Dictionary containing data to export to Excel.

    Returns:
        None

    """
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["export_results_subheader"])
    # Generate a timestamped filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    excel_filename = f"backtest_results_{timestamp}.xlsx"
    excel_file = export_to_excel(excel_export_data, filename=excel_filename)
    st.download_button(
        label=MESSAGES["display_texts"]["messages"]["download_excel_button"],
        data=excel_file,
        file_name=excel_filename,
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )
