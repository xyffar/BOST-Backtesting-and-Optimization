# backtest_runner.py

import os
import time
from datetime import datetime

import numpy as np  # Importa numpy per np.nan
import pandas as pd
import streamlit as st
from backtesting import Backtest

from config import MESSAGES, streamlit_obj
from data_handler import download_data, get_sp500_data
from display_results import display_results
from excel_exporter import export_to_excel, log_execution_data
from monte_carlo import run_montecarlo
from strategies.buy_and_hold_strategy import BuyAndHoldStrategy
from strategies.common_strategy import CommonStrategy


def compare_with_benchmark(strategy_stats: pd.Series, benchmark_stats: pd.Series | None) -> pd.DataFrame:
    """Create a DataFrame that compares the performance metrics of the strategy with the benchmark.

    Metrics include various return measures, volatility, Sharpe ratio, Sortino ratio,
    drawdowns, trade statistics, and other performance indicators.

    Args:
        strategy_stats (pd.Series): Complete statistics from the strategy backtest
                                    (output of `Backtest.run()`).
        benchmark_stats (pd.Series): Complete statistics from the Buy & Hold benchmark
                                     backtest (output of `Backtest.run()`). Can be None
                                     if benchmark data is not available.

    Returns:
        pd.DataFrame: A DataFrame comparing key metrics of the strategy and the benchmark,
                      with metrics as index and 'Strategia' and 'Benchmark (SPY)' as columns.
                      Numeric values are rounded to two decimal places.

    """
    metrics_to_display = [
        "Exposure Time [%]",
        "Equity Final [$]",  # Aggiunto simbolo valuta per chiarezza
        "Equity Peak [$]",  # Aggiunto simbolo valuta per chiarezza
        "Return [%]",
        "Buy & Hold Return [%]",
        "Return (Ann.) [%]",
        "Volatility (Ann.) [%]",
        "Sharpe Ratio",
        "Sortino Ratio",
        "Calmar Ratio",
        "Max. Drawdown [%]",
        "Avg. Drawdown [%]",
        "Max. Drawdown Duration",
        "Avg. Drawdown Duration",
        "# Trades",
        "Win Rate [%]",
        "Best Trade [%]",
        "Worst Trade [%]",
        "Avg. Trade [%]",
        "Max. Trade Duration",
        "Avg. Trade Duration",
        "Profit Factor",
        "Expectancy [%]",
        "SQN",
    ]

    strategy_values = []
    benchmark_values = []

    for metric in metrics_to_display:
        strategy_value = strategy_stats.get(metric, np.nan)
        benchmark_value = benchmark_stats.get(metric, np.nan) if benchmark_stats is not None else np.nan

        # Arrotonda i valori numerici a due cifre decimali
        if isinstance(strategy_value, (int, float)) and not np.isnan(strategy_value) and not np.isinf(strategy_value):
            strategy_values.append(round(strategy_value, 2))
        else:
            strategy_values.append(strategy_value)

        if (
            isinstance(benchmark_value, (int, float))
            and not np.isnan(benchmark_value)
            and not np.isinf(benchmark_value)
        ):
            benchmark_values.append(round(benchmark_value, 2))
        else:
            benchmark_values.append(benchmark_value)

    comparison_df = pd.DataFrame(
        {
            "Metrica": metrics_to_display,
            "Strategia": strategy_values,
            "Benchmark (SPY)": benchmark_values,
        }
    )
    comparison_df.set_index("Metrica", inplace=True)

    return comparison_df


def run_backtest(
    data: pd.DataFrame,
    strategy_name: str,
    params: dict,
    initial_capital: float,
    commission_percent: float,
    is_plot_wanted: bool = True,
) -> tuple[pd.Series | None, str | None, pd.DataFrame | None, str, str]:
    """Run a backtest for a given strategy and data using the `backtesting.py` library.

    Logs execution times and can optionally generate an interactive plot of the equity curve.

    Args:
        data (pd.DataFrame): Historical market data (OHLCV) on which to run the backtest.
                             Must be in the format expected by `backtesting.py`.
        strategy_name (str): The name of the strategy to backtest.
        params (dict): A dictionary of parameters to pass to the strategy's `init` method.
        initial_capital (float): The initial capital for the backtest.
        commission_percent (float): Commission percentage per trade (e.g., 0.002 for 0.2%).
        is_plot_wanted (bool, optional): If True, an interactive Bokeh plot of the
                                         equity curve will be generated and returned as HTML.
                                         Defaults to True.

    Returns:
        tuple: A tuple containing:
               - stats (pd.Series or None): Statistics of the backtest generated by `bt.run()`.
                                            Returns None if the backtest fails.
               - plot_html (str or None): HTML string of the interactive Bokeh plot.
                                          Returns None if `is_plot_wanted` is False or if backtest fails.
               - trades_df (pd.DataFrame or None): DataFrame containing details of individual trades.
                                                   Returns None if the backtest fails.
               - status (str): "success" if the backtest ran without errors, "failure" otherwise.
               - message (str): A descriptive message indicating the outcome or error.

    """
    if data is None or data.empty:
        return (
            None,
            None,
            None,
            "failure",
            "Impossibile eseguire il backtest: dati non disponibili.",
        )
    strat_class: type[CommonStrategy] = st.session_state.all_strategies[strategy_name]
    bt = Backtest(
        data,
        strat_class,
        cash=initial_capital,
        commission=commission_percent,
        exclusive_orders=True,  # Consente una sola posizione alla volta
    )

    try:
        start_time = time.perf_counter()
        stats = bt.run(**params)
        end_time = time.perf_counter()
        pars_time_log = {"periods": len(data), "strategy": strat_class.DISPLAY_NAME}
        log_execution_data(start_time, end_time, action="Backtest", **pars_time_log)

        if is_plot_wanted:
            start_time = time.perf_counter()
            plot_html = bt.plot(filename="TO BE DELETED.html", resample=False, open_browser=False)
            if os.path.exists("TO BE DELETED.html"):
                os.remove("TO BE DELETED.html")
            end_time = time.perf_counter()
            log_execution_data(start_time, end_time, action="Backtest_plot", **pars_time_log)
        else:
            plot_html = None
        trades_df = stats._trades

        return (
            stats,
            plot_html,
            trades_df,
            "success",
            "Backtest completato con successo.",
        )
    except Exception as e:
        return (
            None,
            None,
            None,
            "failure",
            f"Errore durante l'esecuzione del backtest: {e}. "
            "Controlla i parametri della strategia o la logica interna.",
        )


def get_benchmark_data(
    start_date_yf: str,
    end_date_yf: str,
    data_interval: str,
    initial_capital: float,
    commission_percent: float,
    download_progress_placeholder: streamlit_obj,
    download_success_placeholder: streamlit_obj,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
) -> pd.Series | None:
    """Download S&P500 data and run a Buy & Hold backtest on it to serve as a benchmark.

    This function handles the data download process and the subsequent backtest
    execution for the benchmark.

    Args:
        start_date_yf (str): Start date for data download in YYYY-MM-DD format,
                             compatible with `yfinance`.
        end_date_yf (str): End date for data download in YYYY-MM-DD format,
                           compatible with `yfinance`.
        data_interval (str): Data interval (e.g., "1d" for daily, "1h" for hourly).
                             Must be compatible with `yfinance` intervals.
        initial_capital (float): Initial capital for the benchmark backtest.
        commission_percent (float): Commission percentage to apply to the benchmark
                                    Buy & Hold backtest.
        download_progress_placeholder (streamlit.delta_generator.DeltaGenerator):
            A Streamlit placeholder object to display download progress messages.
        download_success_placeholder (streamlit.delta_generator.DeltaGenerator):
            A Streamlit placeholder object to display download success messages.
        successful_downloads_tickers (list): A list to append the ticker of
                                             successfully downloaded data.
        failed_downloads_tickers (list): A list to append the ticker of
                                         failed data downloads.

    Returns:
        pd.Series or None: Statistics of the Buy & Hold benchmark backtest
                           (output of `Backtest.run()`). Returns None if data
                           download or backtest execution fails.

    """
    benchmark_raw_data = None  # Raw benchmark data
    benchmark_stats = None  # Complete benchmark buy&hold statistics

    # Download benchmark data
    download_progress_placeholder.info(
        MESSAGES["display_texts"]["messages"]["downloading_benchmark"].format(
            SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"]
        )
    )
    benchmark_raw_data, status, msg = get_sp500_data(start_date_yf, end_date_yf, data_interval)
    download_progress_placeholder.empty()  # Remove blue progress box

    if status == "success":
        successful_downloads_tickers.append(MESSAGES["general_settings"]["sp500_ticker"])
        download_success_placeholder.success(
            MESSAGES["display_texts"]["messages"]["download_success_benchmark"].format(
                SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"]
            )
        )

        # Run a backtest with BuyAndHold strategy on the benchmark
        if benchmark_raw_data is not None and not benchmark_raw_data.empty:
            try:
                bt_benchmark = Backtest(
                    benchmark_raw_data,
                    BuyAndHoldStrategy,  # Use the BuyAndHold strategy
                    cash=initial_capital,
                    commission=commission_percent,  # Apply commissions to benchmark too for parity
                    exclusive_orders=True,
                )
                benchmark_stats = bt_benchmark.run()
            except Exception as e:
                st.warning(
                    MESSAGES["display_texts"]["messages"]["error_calculating_benchmark_stats"].format(
                        SP500_TICKER=MESSAGES["general_settings"]["sp500_ticker"], e=e
                    )
                )
                benchmark_stats = None
    else:
        failed_downloads_tickers.append(MESSAGES["general_settings"]["sp500_ticker"])
        st.warning(MESSAGES["display_texts"]["messages"]["benchmark_data_not_available"])
    return benchmark_stats


def start_backtest_process(
    tickers: list[str],
    start_date_yf: str,
    end_date_yf: str,
    data_interval: str,
    initial_capital: float,
    commission_percent: float,
    run_mc: bool,
    mc_sampling_method: str,
    sims_length: int,
    num_sims: int,
    strat_name: str,
    strategy_params: dict[str, int | float | str | bool],
    backtest_results_container: streamlit_obj,
) -> None:
    """Run the backtest process for the given tickers and strategy.

    This function manages the download of data, execution of backtests, Monte Carlo simulation, and result export for all selected tickers.

    Args:
        tickers (list[str]): List of ticker symbols to backtest.
        start_date_yf (str): Start date for data download.
        end_date_yf (str): End date for data download.
        data_interval (str): Data granularity (e.g., '1d').
        initial_capital (float): Initial capital for the backtest.
        commission_percent (float): Commission percentage for trades.
        run_mc (bool): Whether to run Monte Carlo simulation.
        mc_sampling_method (str): Monte Carlo sampling method.
        sims_length (int): Number of trades per simulation.
        num_sims (int): Number of Monte Carlo simulations.
        strat_name (str): The name of the selected strategy.
        strategy_params (dict): Parameters for the selected strategy.
        backtest_results_container (streamlit.delta_generator.DeltaGenerator): Streamlit container for displaying backtest results.

    Returns:
        None

    """
    with backtest_results_container:
        col_progress, col_success, col_failed = st.columns(3)
        if not tickers:
            st.error(MESSAGES["display_texts"]["messages"]["enter_ticker_error"])
            return
        elif strat_name is None:
            st.error(MESSAGES["display_texts"]["messages"]["select_valid_strategy_error"])
            return

    all_ticker_results = {}
    excel_export_data = {}
    all_mc_statistics = {}

    # Placeholders for dynamic messages
    with col_progress:
        download_progress_placeholder = st.empty()
        download_success_placeholder = st.empty()
    with col_success:
        run_progress_placeholder = st.empty()
        run_success_placeholder = st.empty()
    with col_failed:
        download_fail_placeholder = st.empty()
        run_fail_placeholder = st.empty()  # For backtest/optimization success/failure messages

    successful_downloads_tickers = []
    failed_downloads_tickers = []
    successful_runs_tickers = []
    failed_runs_tickers = []

    benchmark_stats = get_benchmark_data(
        start_date_yf,
        end_date_yf,
        data_interval,
        initial_capital,
        commission_percent,
        download_progress_placeholder,
        download_success_placeholder,
        successful_downloads_tickers,
        failed_downloads_tickers,
    )

    with backtest_results_container:
        progress_bar = st.progress(0)

        for i, ticker in enumerate(tickers):
            _process_single_ticker(
                ticker,
                i,
                tickers,
                start_date_yf,
                end_date_yf,
                data_interval,
                strat_name,
                strategy_params,
                initial_capital,
                commission_percent,
                run_mc,
                mc_sampling_method,
                sims_length,
                num_sims,
                benchmark_stats,
                download_progress_placeholder,
                download_success_placeholder,
                download_fail_placeholder,
                run_progress_placeholder,
                run_success_placeholder,
                run_fail_placeholder,
                successful_downloads_tickers,
                failed_downloads_tickers,
                successful_runs_tickers,
                failed_runs_tickers,
                all_ticker_results,
                excel_export_data,
                all_mc_statistics,
                progress_bar,
            )
        display_results(ticker_results=all_ticker_results, all_mc_statistics=all_mc_statistics)

        if all_ticker_results:
            _manage_excel_file_backtest(excel_export_data)


def _process_single_ticker(
    ticker: str,
    i: int,
    tickers: list[str],
    start_date_yf: str,
    end_date_yf: str,
    data_interval: str,
    strat_name: str,
    strategy_params: dict[str, int | float | str | bool],
    initial_capital: float,
    commission_percent: float,
    run_mc: bool,
    mc_sampling_method: str,
    sims_length: int,
    num_sims: int,
    benchmark_stats: pd.Series | None,
    download_progress_placeholder: streamlit_obj,
    download_success_placeholder: streamlit_obj,
    download_fail_placeholder: streamlit_obj,
    run_progress_placeholder: streamlit_obj,
    run_success_placeholder: streamlit_obj,
    run_fail_placeholder: streamlit_obj,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
    successful_runs_tickers: list,
    failed_runs_tickers: list,
    all_ticker_results: dict,
    excel_export_data: dict,
    all_mc_statistics: dict,
    progress_bar: streamlit_obj,
) -> None:
    download_progress_placeholder.info(
        MESSAGES["display_texts"]["messages"]["downloading_ticker"].format(
            ticker=ticker, current_idx=i + 1, total_tickers=len(tickers)
        )
    )

    data, status, _ = download_data(ticker, start_date_yf, end_date_yf, data_interval)

    download_progress_placeholder.empty()  # Remove blue progress box

    _update_download_status(
        status,
        ticker,
        successful_downloads_tickers,
        failed_downloads_tickers,
        download_success_placeholder,
        download_fail_placeholder,
    )

    stats, plot_html, trades_df, run_status, _ = (None, None, None, "failure", None)
    if data is not None:
        run_progress_placeholder.info(MESSAGES["display_texts"]["messages"]["execution_in_progress"] + ticker)
        stats, plot_html, trades_df, run_status, _ = run_backtest(
            data,
            strat_name,
            strategy_params,
            initial_capital,
            commission_percent,
        )
        run_progress_placeholder.empty()

    _update_run_status(
        run_status,
        ticker,
        stats,
        plot_html,
        trades_df,
        benchmark_stats,
        successful_runs_tickers,
        failed_runs_tickers,
        run_success_placeholder,
        run_fail_placeholder,
        all_ticker_results,
        excel_export_data,
    )

    progress_bar.progress((i + 1) / len(tickers))

    if run_mc and data is not None and run_status == "success" and trades_df is not None and stats is not None:
        all_mc_statistics[ticker] = run_montecarlo(
            trades=list(trades_df["ReturnPct"]),
            original_stats=stats,
            initial_capital=initial_capital,
            benchmark=benchmark_stats,
            sampling_method=mc_sampling_method,
            sim_length=sims_length,
            num_sims=num_sims,
        )


def _update_download_status(
    status: str,
    ticker: str,
    successful_downloads_tickers: list,
    failed_downloads_tickers: list,
    download_success_placeholder: streamlit_obj,
    download_fail_placeholder: streamlit_obj,
) -> None:
    if status == "success":
        successful_downloads_tickers.append(ticker)
        download_success_placeholder.success(
            MESSAGES["display_texts"]["messages"]["download_success_ticker"] + ", ".join(successful_downloads_tickers)
        )
    else:
        failed_downloads_tickers.append(ticker)
        download_fail_placeholder.error(
            MESSAGES["display_texts"]["messages"]["download_failed_ticker"] + ", ".join(failed_downloads_tickers)
        )


def _update_run_status(
    run_status: str,
    ticker: str,
    stats: pd.Series | None,
    plot_html: str | None,
    trades_df: pd.DataFrame | None,
    benchmark_stats: pd.Series | None,
    successful_runs_tickers: list,
    failed_runs_tickers: list,
    run_success_placeholder: streamlit_obj,
    run_fail_placeholder: streamlit_obj,
    all_ticker_results: dict,
    excel_export_data: dict,
) -> None:
    if run_status == "success":
        successful_runs_tickers.append(ticker)
        run_success_placeholder.success(
            MESSAGES["display_texts"]["messages"]["execution_completed"] + ", ".join(successful_runs_tickers)
        )

        if stats is not None:
            comparison_df = None
            if benchmark_stats is not None:
                comparison_df = compare_with_benchmark(stats, benchmark_stats)
            all_ticker_results[ticker] = (
                stats,
                plot_html,
                trades_df,
                comparison_df,
            )
            excel_export_data[ticker] = (
                stats,
                trades_df,
                comparison_df,
            )
    else:
        failed_runs_tickers.append(ticker)
        run_fail_placeholder.error(
            MESSAGES["display_texts"]["messages"]["execution_failed"] + ", ".join(failed_runs_tickers)
        )


def _manage_excel_file_backtest(excel_export_data: dict) -> None:
    """Manage the export and download of backtest results as an Excel file.

    Args:
        excel_export_data (dict): Dictionary containing data to export to Excel.

    Returns:
        None

    """
    st.markdown("---")
    st.subheader(MESSAGES["display_texts"]["messages"]["export_results_subheader"])
    # Generate a timestamped filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    excel_filename = f"backtest_results_{timestamp}.xlsx"
    excel_file = export_to_excel(excel_export_data, filename=excel_filename)
    st.download_button(
        label=MESSAGES["display_texts"]["messages"]["download_excel_button"],
        data=excel_file,
        file_name=excel_filename,
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )
